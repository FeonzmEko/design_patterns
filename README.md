# UML图

## 类图表示法

### 类的表示方式

![image-20251128144456417](C:\Users\Qingfeng\AppData\Roaming\Typora\typora-user-images\image-20251128144456417.png)

## 类间关系的表示方式



# 软件设计原则

在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可拓展性和灵活性，遵守以下6条原则拉力开发程序，从而提高软件开发效率，节约软件开发成本和维护成本

## 开闭原则

**对拓展开放，对修改关闭。**

在程序需要进行拓展的时候，不能去修改原有代码，实现一个热插拔的效果。简言之，是为了是程序的扩展性更强，易于维护和升级。

## 里氏代换原则

**任何基类可以出现的地方，子类一定可以出现。**

通俗的说：子类可以扩展父类的功能，但不能够改变父类原有的功能。子类继承父类时，处添加新的方法完成新增功能外，尽量不要重写父类的方法。

## 依赖倒转原则

**高层模块不应该依赖于底层模块，两者都应该依赖于抽象。**

**抽象不应该依赖于细节，细节应该依赖于抽象。**

## 接口隔离原则

**客户端不应该依赖它不需要的接口。**

接口要小而专

## 迪米特法则

**一个对象应该对其他对象有最少的了解。**

eg：controller，service，dao层

## 合成复用原则

**尽量使用 组合 (Composition) 或 聚合 (Aggregation)的方式实现代码复用，而不是使用 继承 (Inheritance)。**

# 分类

## 创建型模式

> 用于描述“怎么样创建对象”，特点是对象的创建和使用分离

共有五种

分别是 单例，原型，工厂方法，抽象工厂，建造者

## 结构型模式

> 描述如何将类或对象按某种布局组成更大的结构

共有七种

分别是 代理，适配器，桥接，装饰者，外观，享元，组合

## 行为型模式

> 描述类或对象之间怎样互相协作共同完成单个对象无法完成的任务，以及怎样分配职责

共有十一种

分别是 模板方法，策略，命令，职责链，状态，观察者，中介者，迭代器，访问者，备忘录，解释器



# 创建者模式

创建者模式的主要关注点是“怎样创建对象？”，它的主要关注点是“将对象的创建与使用分离”。

这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。

分类以下五种模式：

* 单例模式
* 工厂方法模式
* 抽象工程模式
* 原型模式
* 建造者模式

## 单例模式

提供了一种创建对象的最佳方式。

这种模式涉及一个单一的类，该类负责创建自己的对象，同时确保只有单个对象会被创建。

### 实现

分为两种：

* 饿汉式：类加载就会导致该单实例对象被创建
* 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用时才会被创建



1. 饿汉式-方式1（静态变量方式）

2. 饿汉式-方式2（静态代码块方式）

3. 饿汉式-方式3（枚举）

   ```java
   public enum Singleton{
       INSTANCE;
   }
   ```

   

4. 懒汉式-方式1（线程不安全）

5. 懒汉式-方式2（双检锁线程安全）

   ```java
   public class Singleton {
   
       private Singleton(){}
       private static volatile Singleton instance;
   
       public static Singleton getInstance(){
           if(instance == null){
               synchronized (Singleton.class){
                   if(instance == null){
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

   

6. 懒汉式-方式4（静态内部类方式）

   ```java
   public class Singleton {
   
       private Singleton() {}
   
       private static class SingletonHolder{
           private static final Singleton INSTANCE = new Singleton();
       }
   
       public static Singleton getInstance(){
           return SingletonHolder.INSTANCE;
       }
   
   }
   ```

### 问题

破坏单例：

- 序列化与反序列化：单例类实现Serializable接口，将对象写入文件后读取，每次读取到的是不同对象
- 反射：将无参构造通过反射设置为可见，然后创建对象，创建得到的是不同对象

反破坏单例：

- 序列化与反序列化：单例类中定义private Object readResolve()方法，方法返回单例对象。因为在反序列化时如果类中有个叫readResolve的方法，就会执行这个方法并返回结果。
- 反射：私有构造方法进行单例对象的非空判断即可，如果不为空，说明已经存在单例对象了，还想反射创建新的单例对象是不允许的，抛异常；为空，允许创建。

单例模式较为简单，但实现方法较多，需要根据不同场景下选择不同方式实现。

## 工厂模式

### 概述

java中，万物皆对象，对象需要创建时，都需要new出来，导致耦合严重，违背了软件设计的开闭原则。当我们运行工厂，只需要和工厂进行打交道，彻底和对象解耦，需要更换对象时，直接在工厂内更换对象，达到了与对象解耦的目的

工厂模式的最大优点：**解耦。**

### 简单工厂模式

简单工厂并非设计模式，更像一种编程习惯。

把类中创建对象的方法抽离到一个工厂中，相当于加了一层。

### 静态工厂模式

把工厂方法设置为静态`static`

### 工厂方法模式

用工厂方法模式可以完美解决上述问题，完全遵守开闭原则。

### 抽象工厂模式

**概念：**一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同组的不同等级的产品的模式结构

抽象工厂模式使工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品